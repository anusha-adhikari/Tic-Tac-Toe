# -*- coding: utf-8 -*-
"""ReinforcedTicTacToe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KJPTLV4tZbCcLu7gc3vxyov0Y5QfHLxb
"""

from copy import deepcopy as dc

class Board():
  #constructor of class Board()
  def __init__(self, board = None):
    #players
    self.player_1 = 'x '
    self.player_2 = 'o '

    #board position
    self.position = {}

    #reset board
    self.resetBoard()

    #copy of prev board position
    if board is not None:
      self.__dict__ = dc(board.__dict__)

  def resetBoard(self):
    #traversing a 2d array -> board
    for rows in range(3):
      for columns in range(3):
        #set every sqaure to '.' to show empty
        self.position[rows, columns] = '. '

  #make move
  def makeMove(self, rows, columns):
    #create new board instance that inherits from the current state 
    board = Board(self)
    #make move
    board.position[rows, columns] = self.player_1

    #switch players
    board.player_1, board.player_2 = board.player_2, board.player_1

    #return new board state
    return board

  #check whether game is draw
  def isDraw(self):
    #loop over board squares
    for row, col in self.position:
      #if empty square is available
      if self.position[row, col] == '. ':
        #this is not a draw
        return False
    
    #by default return drawn state 
    return True

  #check whether game is won
  def isWin(self):

    #vertical sequence detection
    for col in range(3):
      #define winning sequene list
      winningSeq = []
      for row in range(3):
        if self.position[row, col] == self.player_2:
          winningSeq.append((row, col))

        if len(winningSeq) == 3:
          #return winning state
          return True
          
    #horizontal sequence detection
    for row in range(3):
      #define winning sequene list
      winningSeq = []
      for col in range(3):
        if self.position[row, col] == self.player_2:
          winningSeq.append((row, col))

        if len(winningSeq) == 3:
          #return winning state
          return True

    #diagonal sequence detection
    #1st diagonal
    winningSeq = []
    for row in range(3):
      col = row
      if self.position[row, col] == self.player_2:
        winningSeq.append((row, col))

      if len(winningSeq) == 3:
        #return winning state
        return True

    #2nd diagonal
    winningSeq = []
    for row in range(3):
      col = 3 - row - 1
      if self.position[row, col] == self.player_2:
        winningSeq.append((row, col))

      if len(winningSeq) == 3:
        #return winning state
        return True

    #by default return non-winning state
    return False

  def __str__(self):
    #returns string, need a string
    boardStr = ''

    for rows in range(3):
      for columns in range(3):
        boardStr += '%s' % self.position[rows, columns]
      #new line
      boardStr += '\n'

    #prepend side to move
    if self.player_1 == 'x ':
      boardStr = '\n---------------\n Player "x" to move: \n---------------\n\n' + boardStr
    elif self.player_1 == 'o ':
      boardStr = '\n---------------\n Player "o" to move: \n---------------\n\n' + boardStr

    #return string
    return boardStr

  #generate legal moves to play in current pos
  def generateStates(self):
    #define states list of available actions to consider
    actions = [] #board class instances

    #loop for board rows
    for row in range(3):
      for col in range(3):
        #make sure that current square is empty
        if self.position[row, col] == '. ':
          #append available action/board state to board list
          actions.append(self.makeMove(row, col))

    #return the list of available actions 
    return actions

  #main game loop
  def gameLoop(self):
    print("TIC TAC TOE: ")
    print(' Type "exit" to quit game')
    print(' Move format is [m][n] where m is row and n is column ')
    print(' Rows -> 1, 2, 3 ')
    print(' Columns -> 1, 2, 3 ')

    #print board
    print(self)

    # create MCTS instance
    mcts = MCTS()

    #game loop
    while True:
      #user input
      userInput = input('> ')

      #escape condition
      if userInput == 'exit' or userInput == ' exit' or userInput == 'exit ': break

      #skip empty input
      if userInput == '': continue

      try:
        #parse user input (move format [row, col]: 1, 2)
        row = int(userInput.split(',')[0]) - 1
        col = int(userInput.split(',')[-1]) - 1

        #check move on board
        if self.position[row, col] != '. ':
          print("Illegal Move!")
          continue

        #make move on board
        self = self.makeMove(row, col)

        #print board
        print(self)

        #search best move
        bestMove = mcts.search(self)

        # legal moves available
        try:
          #make AI move
          self = bestMove.board

        # game over
        except:
          #print('error: ', e)
          pass
        
        #print board
        print(self)

        #check if game is won
        if self.isWin():
          print('Player " %s" won the game ' % self.player_2)
          break

        #check if game is drawn
        elif self.isDraw():
          print("Draw")
          break

      except Exception as e:
        print('Error: ', e)
        print('Illegal Command!')
        print('Move format is [m][n] where m is row and n is column ')
        print(' Rows -> 1, 2, 3 ')
        print(' Columns -> 1, 2, 3 ')

#MCTS algorithm implementation

import math
import random

#tree node class definition 
class TreeNode():
  #class constructor
  def __init__(self, board, parent):
    #initialize associated board state
    self.board = board

    #terminal(flag)
    if self.board.isWin() or self.board.isDraw():
      self.isTerminal = True
    
    else:
      self.isTerminal = False

    #initialize parent node if available
    self.parent = parent

    #initialize no.of nodes visited
    self.visits = 0

    #initialize total score of the node
    self.score = 0

    #initialize current node's children
    self.children = {}

    #initialize is fully expanded flag
    self.isFullyExpanded = self.isTerminal

# MCTS class
class MCTS:
  # search for the best move in the current position
  def search(self, initialState):
    # create root node
    self.root = TreeNode(initialState, None)

    # search 1000 iterations (fixed number -> better time complexity)
    for iteration in range(1000):
      # select node ( selection phase )
      node = self.select(self.root)

      # score current node ( simulation phase )
      score = self.rollout(node.board)

      # backpropagate results
      self.backpropagate(node, score)

    #pick up the best move in the current position
    try:
      return self.getBestMove(self.root, 0)

    except:
      pass

  # select the most promising node
  def select(self, node):
    #make sure that we're dealing with non-terminal nodes
    while not node.isTerminal:
      # case when node is fully expanded
      if node.isFullyExpanded:
        node = self.getBestMove(node, 2)

      # where the node is not fully expanded
      else:
        #otherwise, expand the node
        return self.expand(node)

    #return node
    return node

  #expand node
  def expand(self, node):
    #generate legal states(moves) for the given node
    states = node.board.generateStates()

    #loop over generated states (moves)
    for state in states:
      #make sure that the current state is not present in the children nodes
      if str(state.position) not in node.children:
        #create a new node
        newNode = TreeNode(state, node)
                           
        #add child node to parent node's children list(dict)
        node.children[str(state.position)] = newNode

        #condition when node is fully expanded or not
        if len(states) == len(node.children):
          node.isFullyExpanded = True

        #return newly creates node
        return newNode

    #debugging
    print("Not working properly")

  # simulate the game by making random moves until end of game
  def rollout(self, board):
    # make random moves for both sides until teriminal state of the board is reached
    while not board.isWin():
      # try to make a move
      try:
        # make the move on board
        board = random.choice(board.generateStates())
        #print(board)

      # no moves available
      except:
        #print(board)
        #print("draw state: ", board.isDraw())
        # return a draw score
        return 0

    #print('Win State: ', board.isWin())

    #print(board)

    if board.player_2 == 'x ': return 1
    elif board.player_2 =='o ': return -1


  # backpropagate no.of visits and score up to the root node
  def backpropagate(self, node, score):
    # update nodes upto root node
    while node is not None:
      # update node visits
      node.visits += 1

      # update node's score
      node.score += score

      #set node to parent
      node = node.parent
  
  # select the best node basing on UCT (Upper Confidence Bound 1 to Trees) formula 
  def getBestMove(self, node, explorationConst):
    # define best score and best move
    bestScore = float('-inf')
    bestMoves = []

    #loop over child nodes
    for childNode in node.children.values():
      # define current player
      if childNode.board.player_2 == 'x ' : currentPlayer = 1
      elif childNode.board.player_2 == 'o ' : currentPlayer = -1

      # get moves score using UCT
      moveScore = currentPlayer * childNode.score / childNode.visits + explorationConst * math.sqrt(math.log(node.visits) / childNode.visits)
      #print("Move Score: ", moveScore)

      # better move found
      if moveScore > bestScore:
        bestScore = moveScore
        bestMoves = [childNode]

      #found the best available move
      elif moveScore == bestScore:
        bestMoves.append(childNode)

    #return one of the best moves randomly
    return random.choice(bestMoves)

#main driver
if __name__ == '__main__':
  #create board instance
  board = Board()
  
  #start game loop
  board.gameLoop()





